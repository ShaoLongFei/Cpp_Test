## 初始化

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来;相反，如果指明了维度，那么**初始值的总数量不应该超出指定的大小**。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。

```c++
const unsigned sz = 3;
int ial[sz] = {0, 1, 2}; // 含有 3 个元素的数组,元素值分别是 0, 1, 2
int a2[] = {0, 1, 2}; // 维度是 3 的数组
int a3[5] = {0, 1, 2}; // 等价于 a3[] = {0,1,2,0，0}
string a4[3] = {"hi", "bye"}; // 等价于 a4[] = {"hi", "bye", ""}
int a5[2] = {0, 1, 2}; // 错误:初始值过多
```

**注意：如果用字符串初始化字符数组，不要忘记字符串最后有一个隐藏的 '\0'**

```c++
char a3[] = "C++"; // 自动添加表示字符串结束的空字符，长度为 4
const char a4[6] = "Daniel"; // 错误:没有空间可存放空字符!
```

**不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值**

```c++
int a[] = {0, 1, 2}; // 含有 3 个整数的数组
int a2[] = a; // 错误:不允许使用一个数组初始化另一个数组
a2 = a; // 错误:不能把一个数组直接赋值给另一个数组
```

一些编译器支持数组的赋值，这就是所谓的编译器扩展。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。

## 特性

**在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针:**

```c++
string *p2 = nums; // 等价于 p2 = &nums[0]
```

在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

由上可知，在一些情况下数组的操作实际上是指针的操作，这一结论有很多隐含的意思。其中一层意思是当使用数组作为一个 auto 变量的初始值时，推断得到的类型是指针而非数组:

```c++
int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; // ia 是一个含有 10 个整数的数组
auto ia2(ia); // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42; // 错误: ia2 是一个指针，不能用 int 值给指针赋值
```

尽管 ia 是由 10个 整数构成的数组，但当使用 ia 作为初始值时，编译器实际执行的初始化过程类似于下面的形式:

```c++
auto ia2(&ia[0]); // 显然 ia2 的类型是 int*
```

必须指出的是，当使用 decltype 关键字时上述转换不会发生，decltype(ia) 返回的类型是由 10 个整数构成的数组:

```c++
// ia3 是一个含有 10 个整数的数组
decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int num = 10;
int *p = &num;
ia3 = p; // 错误:不能用整型指针给数组赋值
ia3[4] = 10; // 正确:赋值给 ia3 的一个元素
```

## 初始化 vector

不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用 vector 对象初始化数组。但允许使用数组来初始化 vector 对象。只需指明要拷贝区域的首元素地址和尾后地址就可以了:

```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
// ivec 有 6 个元素，分别是 int_arr 中对应元素的副本.
vector<int> ivec(begin(int_arr), end(int_arr));
```

> **建议：直接使用标准库类型而非数组**
>
> 现代的C++程序应当尽量使用 vector 和迭代器，避免使用内置数组和指针;应该尽量使用 string,避免使用C风格的基于数组的字符串。

