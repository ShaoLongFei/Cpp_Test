## switch 内部变量定义

如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。

```c++
bool ret = false;
switch (ret) {
    case true : // 因为程序的执行流程可能绕开下面的初始化语句，所以该 switch 语句不合法
        string file_name; // 错误:控制流绕过一个隐式初始化的变量
        int ival = 0; // 错误:控制流绕过一个显式初始化的变量
        int jval; // 正确:因为 jval 没有初始化
        break;
    case false: // 正确:jval 虽然在作用域内，但是它没有被初始化
        jval = 666; //正确:给 jval 赋一个值
        if (file_name.empty()) { // file_name 在作用域内，但是没有被初始化
            cout << "file_name is empty" << endl;
        }
        break;
}
```

假设上述代码合法，则一旦控制流直接跳到 false 分支,也就同时略过了变量 file_name 和 ival 的初始化过程。此时这两个变量位于作用域之内，跟在 false 之后的代码试图在尚未初始化的情况下使用它们，这显然是行不通的。因此C++语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。如果需要为某个 case 分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有 case 标签都在变量的作用域之外。