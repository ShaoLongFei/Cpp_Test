C++语言定义了初始化的好几种不同形式，这也是初始化问题复杂性的一个体现。例如，要想定义一个名为 units_sold 的 int 变量并初始化为 0，以下的4条语句都可以做到这一点:

```c++
int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
```

作为 C++11 新标准的一部分， 用花括号来初始化变量得到了全面应用，而在此之前，这种初始化的形式仅在某些受限的场合下才能使用。这种初始化的形式被称为列表初始化。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。  

当用于内置类型的变量时，这种初始化形式有一个重要特点:如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

```c++
long double ld = 3.1415926536;
int a{ld}, b = {ld}; // 错误：转换未执行，因为存在丢失信息的危险
int c(ld), d = ld; // 正确：转换执行，且确实丢失了部分值
```

>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为 0。一种例外情况是，定义在函数体内部的内置类型变量将不被初始化。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

**建议初始化每一个内置类型的变量。虽然并非必须这么做，但如果我们不能确保初始化后程序安全，那么这么做不失为一种简单可靠的方法。**