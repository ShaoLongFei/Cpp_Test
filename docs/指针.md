**指针通常难以理解，即使是有经验的程序员也尝尝因为调试指针引发的错误而备受折磨**

```c++
double dval;
double *pd = &dval; // 正确:初始值是 double 型对象的地址
double *pd2 = pd; // 正确:初始值是指向 double 对象的指针
int *pi = pd; // 错误:指针 pi 的类型和 pd 的类型不匹配
pi = &dval; // 错误:试图把 double 型对象的地址赋给 int 型指针
```

**指针的值(即地址)应属下列 4 种状态之一:**  
1. 指向一个对象。  
2. 指向紧邻对象所占空间的下一个位置。  
3. 空指针，意味着指针没有指向任何对象。  
4. 无效指针，也就是上述情况之外的其他值。

试图拷贝或以其他方式访问无效指针的值都将引发错误。编译器并不负责检查此类错误

> 建议：初始化所有指针！
> 使用未经初始化的指针是引发运行时错误的一大原因。和其他变量一样，访问未经初始化的指针所引发的后果也是无法预计的。通常这一行为将造成程序崩溃，而且一旦崩溃，要想定位到出错位置将是特别棘手的问题。在大多数编译器环境下，如果使用了未经初始化的指针，则该指针所占内存空间的当前内容将被看作一个地址值。访问该指针，相当于去访问一个本不存在的位置上的本不存在的对象。糟糕的是，如果指针所占内存空间中恰好有内容，而这些内容又被当作了某个地址，我们就很难分清它到底是合法的还是非法的了。  
> 因此建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为 nullptr 或者 0,这样程序就能检测并知道它没有指向任何具体的对象了。

### 指针和引用的区别
指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。

>有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象。当写出如下语句时，
>
>```c++
>pi = &ival; // pi 的值被改变，现在 pi 指向了 ival。
>```
>
>意思是为 pi 赋一个新的值，也就是改变了那个存放在 pi 内的地址值。相反的，如果写出如下语句，
>
>```c++
>*pi = 0; // ival 的值被改变，指针 pi 并没有改变
>```
>
>则 \*pi (也就是指针 pi 指向的那个对象)发生改变。

### void* 指针
void* 是一种特殊的指针类型，可用于存放任意对象的地址。

```c++
double obj = 3.14, *pd = &obj; // 正确: void* 能存放任意类型对象的地址
void *pv = &obj; // obj 可以是任意类型的对象
pV = pd; // pv 可以存放任意类型的指针
```

利用 void* 指针能做的事儿比较有限:拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个 void* 指针。不能直接操作 void* 指针所指的对象，因为我们并不知道这个对象到底是什么类型，也就无法确定能在这个对象上做哪些操作。

### 指向指针的引用
引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用:

```c++
int i=42;
int *p; // p 是一个 int 型指针
int *&r = p; // r 是一个对指针 p 的引用
r=&i; // r 引用了一个指针，因此给 r 赋值 &i 就是令 p 指向 i
*r=0; // 解引用 r 得到 i,也就是 p 指向的对象，将 i 的值改为 0
```

要理解 r 的类型到底是什么，最简单的办法是从右向左阅读 r 的定义。离变量名最近的符号(此例中是 &r 的符号&)对变量的类型有最直接的影响，因此 r 是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号 * 说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 int 指针。

```c++
int i=0;
int *const p1 = &i; //不能改变p1的值，这是一个顶层const
const int ci = 42;
//不能改变ci的值，这是一个顶层const
const int *p2 = &Ci;
//允许改变p2的值，这是一个底层const
```