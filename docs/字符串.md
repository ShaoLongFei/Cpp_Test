## 字符串相加

```c++
string s1 = "Hello";
string s2 = "World";
string s3 = s1 + " " + s2; // 正确
string s4 = s1 + s2; // 正确
string s5 = "Hello" + "World"; // 错误
```

**因为某些历史原因，也为了与 C 兼容，所以 C++ 语言中的字符串字面值并不是标准库类型 string 的对象。切记，字符串字面值与 string 是不同的类型。**

> C++ 标准库中除了定义 C++ 语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如name.h，C++ 则将这些文件命名为 cname。也就是去掉了 .h 后缀，而在文件名 name 之前添加了字母 C，这里的 c 表示这是一个属于 C语言标准库的头文件。因此，cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别的，在名为 cname 的头文件中定义的名字从属于命名空间 std，而定义在名为 .h 的头文件中的则不然。
> 一般来说，C++ 程序应该使用名为 cname 的头文件而不使用 name.h 的形式，标准库中的名字总能在命名空间 std 中找到。如果使用 .h 形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是 C++ 语言所独有的。

## C 风格字符串

> 尽管 C++ 支持C风格字符串，但在 C++ 程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。

C风格字符串不是一种类型， 而是为了表达和使用字符串而形成的一种约定俗成的写法。按此习惯书写的字符串存放在字符数组中并以空字符结束。以空字符结束的意思是在字符串最后一个字符后面跟着一个空字符(' \0' )，一般利用指针来操作这些字符串。

以下这些 C 风格字符串不负责校验参数，使用时应注意：

- strlen(p) ：返回 p 的长度，空字符不计算在内。
- strcmp(p1, p2) ：比较 p1 和 p2 的相等性。如果 p1==p2,返回 0;如果 p1>p2，返回一个正值;如果 p1<p2，返回一个负值。
- strcat (p1, p2)：将 p2 附加到 p1 之后，返回 p1。
- strcpy(p1, p2)：将 p2 拷贝给 p1,返回 p1。

有些 C++ 程序在标准库出现之前就已经写成了，它们肯定没用到 string。或者，有些 C++ 程序实际上是与C语言或其他语言的接口程序，当然也无法使用 C++ 标准库，为此，C++ 还提供了一组功能来方便与这些 C 风格字符串的转换。

一般情况下，任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代:

* 允许使用以空字符结束的字符数组来初始化 string 对象或为 string 对象赋值。
* 在 string 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运
  算对象(不能两个运算对象都是)。
* 在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

上述性质反过来就不成立了: **如果程序的某处需要一个C风格字符串，无法直接用 string 来代替它。**为此，C++ 为其提供了 c_str 的成员函数来进行这种转换。

```c++
string s("Hello World!");
char *str = s; // 错误:不能用 string 对象初始化 char*
const char *str = s.c_str(); // 正确
```

但我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用。**如果执行完 c_str() 函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。**

