```c++
unsigned char C = -1; // 假设char占8比特，c的值为255
signed char c2 = 256; // 假设char占8比特，c2的值是未定义的
```

* 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8 比特大小的unsigned char可以表示 0 至 255 区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对 256 取模后所得的余数。因此，把-1 赋给8比特大小的unsigned char 所得的结果是 255。
* 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。

>建议：避免无法预知和依赖于实现环境的行为
>
>无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误。不幸的是,在某些情况和或某些编译器下，含有无法预知行为的程序也能正确执行。但是我们却无法保证同样一个程序在别的编译器下能正常工作，甚至已经编译通过的代码再次执行也可能会出错。此外，也不能认为这样的程序对一组输入有效，对另一组输入就一定有效。
>
>程序也应该尽量避免依赖于实现环境的行为。如果我们把 int 的尺寸看成是一个确定不变的已知值，那么这样的程序就称作不可移植的。当程序移植到别的机器上后，依赖于实现环境的程序就可能发生错误。要从过去的代码中定位这类错误可不是一件轻松愉快的工作。

```c++
unsigned u = 10;
int i = -42;
std::cout << i + i << std::endl; // 输出 -84
std::cout << u + i << std::endl; // 如果 int 占 32 位，输出 4294967264

unsigned u1 = 42, u2 = 10;
std::cout << u1 - u2 << std::endl; // 正确：输出 32
std::cout << u2 - u1 << std::endl; // 正确：不过，结果是取模后的值，4294967264
```

尽管我们不会故意给无符号对象赋一个负值，却可能(特别容易)写出这么做的代码。例如，当一个算术表达式中既有无符号数又有 int 值时，那个 int 值就会转换成无符号数。把 int 转换成无符号数的过程和把 int 直接赋给无符号变量一样。

## 强制类型转换

### static_cast

任何具有明确定义的类型转换，只要不包含底层 const,都可以使用 static_cast。例如通过将一个运算对象强制转换成 double 类型就能使表达式执行浮点数除法:

```c++
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;
```

### const_cast

const_cast 只能改变运算对象的底层 const。

```c++
const char *pc;
char *p = const_cast<char *>(pc); // 正确:但是通过 p 写值是未定义的行为
```

如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。

### reinterpret_cast

reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。举个例子，假设有如下的转换

```c++
int *ip;
char *pd = reinterpret_cast<char *> (ip);
```

我们必须牢记 pd 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在返回吋发生错误。reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。

> 强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。这个建议对于 reinterpret_cast 尤其适用，因为此类类型转换总是充满了风险。在有重载函数的上下文中使用 const_cast 无可厚非，但是在其他情况下使用 const_cast 也就意味着程序存在某种设计缺陷。其他强制类型转换，比如 static_cast 和 dynamic_cast, 都不应该频繁使用。每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并且记录对相关类型的所有假定，这样可以减少错误发生的机会。